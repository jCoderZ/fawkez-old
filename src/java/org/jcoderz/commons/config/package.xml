<body>
<section>
<title>Overview</title>
<p>
   The Configuration Service provides the usage and maintenance of
   configuration.
</p>
<p>
   A service of a Application uses the Configuration Service to get access
   to its configuration data.
</p>
<p>
   The functionality this component offers are:
   <ul>
      <li>providing a well formed and typed interface for other services, </li>
      <li>reading the configuration data from the database
          (or a Resource Bundle File), </li>
      <li>caching the configuration data in order to provide fast access.</li>
   </ul>
</p>

<p>
   The current version implementation does not provide
   <ul>
      <li>manipulation of configuration data, </li>
      <li>updating the internal cache if the configuration data has been changed
          by an administrator, </li>
      <li>notifying the other services about cache updates (MultiCast or JMS)
          using Read Mostly Pattern.</li>
   </ul>
   The modification and update feature is planned for the next release.
</p>
</section>

<section>
<title>Key Requirements</title>
<p>
   There are some key requirements and system constraints that have a
   significant bearing on the architecture for the Configuration Service.
   <ul>
      <li>The main goal is the unified handling of service configuration.</li>
      <li>Very fast modification of service parameters is essential.</li>
      <li>Provide service configuration capabilities without burdening the
          application.</li>
      <li>The Configuration Service should be maintained via the
          AdministrationService.</li>
      <li>Reduce code complexity and maintenance efforts by using code
          generation.</li>
      <li>A kind of 'commit/rollback' mechanism should be provided.
          [planned]</li>
      <li>Configuration changes should be consistent over multiple, concurrent
          application server lines and carried out simultaneous over all
          application server lines. [planned]</li>
      <li>Every configuration modification has to be logged in order to allow
          back tracing. This has to be carried out by the AdministrationService
          and not by the ConfigurationService. [planned]</li>
      <li>An update is carried out simultaneously over all application
          server lines. [planned]</li>
      <li>Usage of Container Managed Persistency for most Entity Beans</li>
      <li>Usage of Type-safe, well-formed and well-checkable Interface
          Parameter-Types</li>
   </ul>
</p>
</section>

<section>
<title>Logical View</title>
<p>
   The Commons Configuration Service is an internal component that is used
   by Applications.
</p>
<p>
   The Configuration Service uses the jCoderZ Service Framework where the
   administration part and the online service part are each represented by a
   Stateless Session Bean. An Administration Interface and Service Interface
   must be implemented.
</p>
<p>
   The following classes are derived from the service framework pattern:
   <ul>
      <li>ConfigurationServiceAdminBean</li>
      <li>ConfigurationServiceAdminInterface</li>
      <li>ConfigurationServiceBean</li>
      <li>ConfigurationServiceInterface</li>
      <li>ConfiguratonServiceCommonInterface</li>
      <li>ConfigurationServiceClientFactory (generated by XSLT)</li>
      <li>ConfigurationServiceContainerFactory (generated by XSLT)</li>
      <li>ConfigurationServiceException (generated by XSLT)</li>
   </ul>
</p>
<p>
   The common configuration interface ConfiguratonServiceCommonInterface is
   defined to provide common methods to both the online and administration
   interface by extending this common interface, and extending its
   implementation.
<diagram type="class" name="ConfigurationServiceInterface">
   <class name="org.jcoderz.commons.config.ConfigurationServiceCommonInterface"/>
   <class name="org.jcoderz.commons.config.ConfigurationServiceAdminInterface"/>
   <class name="org.jcoderz.commons.config.ConfigurationServiceInterface"/>
   <class name="org.jcoderz.commons.config.ConfigurationServiceCommonImpl"/>
   <class name="org.jcoderz.commons.config.ConfigurationServiceAdminImpl"/>
   <class name="org.jcoderz.commons.config.ConfigurationServiceImpl"/>
   <description>
   The Configuration Service service interface.
   </description>
</diagram>
</p>

<section>
<title>ConfigurationCacheInterface and its implementations</title>
<p>
   A data access layer is built by providing a general Interface
   ConfigurationCacheInterface, that can be implemented for different backend
   resources like a database or a Java resource property file.
</p>
<p>
   The class ConfigurationCacheByDbReadOnlyImpl represents an implementation
   where the configuration data is stored within a database table.
   The class ConfigurationCacheByPropertesImpl represents an implementation
   where the configuration data is stored within a java property file.
<diagram type="class" name="ConfigurationServiceCache">
   <class name="org.jcoderz.commons.config.ConfigurationCacheInterface"/>
   <class name="org.jcoderz.commons.config.ConfigurationCacheByDbReadOnlyImpl"/>
   <class name="org.jcoderz.commons.config.ConfigurationCacheByPropertiesImpl"/>
   <description>
   The basic classes of the Configuration Service (cache).
   </description>
</diagram>
</p>
</section>

<section>
<title>ConfigurationListener, ConfigCacheUpdateEvent</title>
<p>
   An update mechanism is already prepared with help of ConfigurationListener
   and ConfigUpdateEvent.
</p>
</section>

<section>
<title>ContainerFactory, ClientFactory, ServiceConfiguration</title>
<p>
   The service specific *Service*ContainerFactory and *Service*ClientFactory
   provide factory methods to create a configuration object with a wellformed
   and typed interface for this service by implementing the
   *Service*Configuration interface.
</p>
<p>
   These typed interfaces that are related to its specific service must be used
   in a service to get access to its configuration data.
</p>
<p>
   All these classes are generated by XSLT (ConfigurationClassesGenerator)
   from the service declaration app-info.xml and the included
   *service*-info.xml files (group tag, service attribute, and
   configEntry tags).
</p>
</section>
</section>

<section>
<title>Implementation View</title>
<p>
   Beside to the Configuration Service Interface description, some
   implementation specific details are given.
</p>
<section>
<title>Configuration Entry Declaration</title>
<p>
   The needed configuration parameters are declared within the specific service
   declaration by a XML structure.
   For each configuration parameter its name, a description, the type
   (Java type), serialization and deserialization methods, a default value,
   and roles, which are allowed to modify values, can be specified.
</p>
<p>
   In the current implementation the roles features is not supported, because in
   the first release no configuration value modification is possible.
   The modification feature is planned for future releases.
</p>
<p>
   The declared type is used for the wellformed and typed
   *Service*Configuration interface. The generated classes do perform the
   necessary type conversions from the primitive type String used in the dabase
   layer with help of the serialization and deserialization methods.
</p>
</section>

<section>
<title>Usage</title>
<p>
   In order to increase the performance, every service should only create its
   *Service*Configuration instance once. Thus the configuration data is read
   only once into the data cache.

   Example from Security Service:
   <pre>
 /** the cached instance of the service configuration */
 private SecurityServiceConfiguration mConfig;

 /**
  * Get the config instance.
  * @return the SecurityServiceConfiguration instance
  */
 private final SecurityServiceConfiguration getConfig ()
 {
    if (mConfig == null)
    {
       mConfig
             = SecurityServiceContainerFactory.getLocalServiceConfiguration();
    }
    return mConfig;
 }
   </pre>
</p>
<p>
<diagram type="class" name="ConfigurationServiceSample">
   <!--<class name="org.jcoderz.commons.config.ConfigurationListener"/>
   <class name="org.jcoderz.commons.config.ConfigUpdateEvent"/>
   -->
   <class name="org.jcoderz.commons.connector.ConnectorConfiguration"/>
   <class name="org.jcoderz.commons.connector.ConnectorConfigurationImpl"/>
   <class name="org.jcoderz.commons.connector.ConnectorConfigurationKeys"/>
   <description>
   Sample. Generated classes.
   </description>
</diagram>
</p>
</section>

<section>
<title>Read Only Bean for Database Access Layer</title>
<p>
   The database access layer is implemented with help of
   CMP Read Only EntityBeans, which are provided by BEA Weblogic.

   Beside the common CMP EntityBean, a second ReadOnly EntityBean is
   additionally declared and used in the ConfigurationCacheByDbReadOnlyImpl
   implementation. The ConfigEntityHelper provides its finder method in two
   characteristics, to return the read and writable ConfigEntity objects and to
   return the read-only ConfigReaderEntity objects.

   The ReadOnly EntityBean ConfigReaderEntity is generated with the ant target
   add-readonly-entities and its task make-readonly-beans defined in build.xml.
</p>
</section>

<section>
<title>API</title>

   <apidoc name="config">
      <class name="org.jcoderz.commons.config.ConfigurationServiceCommonInterface"/>
      <class name="org.jcoderz.commons.config.ConfigurationServiceAdminInterface"/>
      <class name="org.jcoderz.commons.config.ConfigurationServiceInterface"/>
      <class name="org.jcoderz.commons.config.ConfigurationServiceCommonImpl"/>
      <class name="org.jcoderz.commons.config.ConfigurationServiceAdminImpl"/>
      <class name="org.jcoderz.commons.config.ConfigurationServiceImpl"/>
   </apidoc>
</section>

<section>
<title>Database Schema</title>
</section>
<diagram type="ER" name="cfgSchema" file="src/sql/cfg_create_tables.sql">
   <description>
   ER-Diagram of the configuration service.
   </description>
</diagram>
</section>
</body>
